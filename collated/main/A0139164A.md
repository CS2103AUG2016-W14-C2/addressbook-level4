# A0139164A
###### \java\seedu\menion\background\SendEmail.java
``` java
public class SendEmail {

    public static final String MESSAGE_BODY = "Hey you missed a task deadline! Here is the info: ";
    public static final String EMAIL_SUBJECT = "Menion! You missed a deadline!";
    
    final String senderEmailID = "menioncena@gmail.com";
    final String senderPassword = "johncena2103";
    final String emailSMTPserver = "smtp.gmail.com";
    final String emailServerPort = "465";
    
    /**
     * Variables that will be set in send method.
     */
    String userEmail = null;
    String emailBody = null;
    String motivationalQuote = null;
    String remind = UnremindCommand.REMINDER_OFF;

    // public void send(ReadOnlyActivity dub) {

    public void send(ReadOnlyActivity outdated) throws FileNotFoundException, MessagingException {

        // Retrieve the email of the user from the txt file.
        Scanner fromFile = new Scanner(new File(Messages.MESSAGE_FILE));
        remind = fromFile.next();
        fromFile.nextLine(); // Skips a line.
        userEmail = fromFile.nextLine();
        fromFile.close(); // close input file stream

        if (remind.equals(RemindCommand.REMINDER_ON)) {

            Properties props = new Properties();
            props.put("mail.smtp.user", senderEmailID);
            props.put("mail.smtp.host", emailSMTPserver);
            props.put("mail.smtp.port", emailServerPort);
            props.put("mail.smtp.starttls.enable", "true");
            props.put("mail.smtp.auth", "true");
            // props.put("mail.smtp.debug", "true");
            props.put("mail.smtp.socketFactory.port", emailServerPort);
            props.put("mail.smtp.socketFactory.class", "javax.net.ssl.SSLSocketFactory");
            props.put("mail.smtp.socketFactory.fallback", "false");

            SecurityManager security = System.getSecurityManager();

            Authenticator auth = new SMTPAuthenticator();
            Session session = Session.getInstance(props, auth);
            // session.setDebug(true);

            MimeMessage msg = new MimeMessage(session);
            emailBody = getMessageBody(outdated);
            msg.setText(emailBody);
            msg.setSubject(EMAIL_SUBJECT);
            msg.setFrom(new InternetAddress(senderEmailID));
            msg.addRecipient(Message.RecipientType.TO, new InternetAddress(userEmail));
            Transport.send(msg);
        }
        else {
            throw new MessagingException();
        }
    }

    public String getMessageBody(ReadOnlyActivity outdated) {
        StringBuilder build = new StringBuilder();

        build.append(MESSAGE_BODY);
        build.append("\n\n");
        build.append("Task name: " + outdated.getActivityName().toString());
        build.append("\n");
        build.append("Task note: " + outdated.getNote().toString());
        build.append("\n");
        build.append("Task date: " + outdated.getActivityStartDate().toString());
        build.append("\n");
        build.append("Task time: " + outdated.getActivityStartTime().toString());
        build.append("\n\n");
        build.append("'");
        build.append(MotivationalQuotes.getRandomQuote());
        build.append("'");

        return build.toString();
    }

    public class SMTPAuthenticator extends javax.mail.Authenticator {
        public PasswordAuthentication getPasswordAuthentication() {
            return new PasswordAuthentication(senderEmailID, senderPassword);
        }
    }
}
```
###### \java\seedu\menion\commons\core\MotivationalQuotes.java
``` java
/**
 * Update here the number of quotes, Currently there is : 20
 * A class to return a random quote from a list.
 */
public class MotivationalQuotes {

    public static String getRandomQuote() {
        ArrayList<String> quotes = new ArrayList<String>();
        Random ran = new Random();
        int random = ran.nextInt(20);
        
        quotes.add("Don’t let what you cannot do interfere with what you can do. – John Wooden");
        quotes.add("It always seems impossible until it’s done.");
        quotes.add("You have to expect things of yourself before you can do them.");
        quotes.add("Believe you can and you’re halfway there.");
        quotes.add("Start where you are. Use what you have. Do what you can. – Arthur Ashe");
        quotes.add("Successful and unsuccessful people do not vary greatly in their abilities. They vary in their desires to reach their potential. – John Maxwell");
        quotes.add("Strive for progress, not perfection.");
        quotes.add("Don’t wish it were easier; wish you were better. – Jim Rohn");
        quotes.add("The secret to getting ahead is getting started.");
        quotes.add("You don’t have to be great to start, but you have to start to be great.");
        quotes.add("Push yourself, because no one else is going to do it for you.");
        quotes.add("There is no substitute for hard work. – Thomas Edison");
        quotes.add("The difference between ordinary and extraordinary is that little 'extra'");
        quotes.add("If people only knew how hard I’ve worked to gain my mastery, it wouldn’t seem so wonderful at all. – Michelangelo");
        quotes.add("If it is important to you, you will find a way. If not, you will find an excuse.");
        quotes.add("Don’t say you don’t have enough time. You have exactly the same number of hours per day that were given to Helen Keller, Pasteur, Michelangelo, Mother Teresea, Leonardo da Vinci, Thomas Jefferson, and Albert Einstein. – H. Jackson Brown Jr.");
        quotes.add("If you’re going through hell, keep going. – Winston Churchill");
        quotes.add("There are no traffic jams on the extra mile. – Zig Ziglar");
        quotes.add("The only place where success comes before work is in the dictionary. – Vidal Sassoon");
        quotes.add("It’s not about how bad you want it. It’s about how hard you’re willing to work for it.");
                
        return quotes.get(random);
    }
}
```
###### \java\seedu\menion\commons\util\DateChecker.java
``` java
public class DateChecker {
    
    public static final String END_DATE_BEFORE_START_DATE_ERROR = "Oh no! Menion has detected that the end date/time of your event is before the " +
                                                                  "start date/time of your event. Please try again!";
    public DateChecker() {
        
    }
    
    /**
     * Checks if Time will exceed the 24hour format.
     */
    public void validTime(String time) throws IllegalValueException {
        int valueOfMinute = Integer.valueOf(time.substring(2));
        int valueOfTime = Integer.valueOf(time);
        
        if (valueOfTime > 2359 || valueOfTime < 0) {
            throw new IllegalValueException(ActivityTime.ACTIVITY_TIME_CONSTRAINTS);
        }
        if (valueOfMinute > 59 || valueOfMinute < 0) {
            throw new IllegalValueException(ActivityTime.ACTIVITY_TIME_CONSTRAINTS);
        }
    }
    
    public void validDate(String date) throws IllegalValueException {
        String[] valueOfDate = date.toString().split("-");

        int valueOfYear = Integer.valueOf(valueOfDate[2]);
        int valueofMonth = Integer.valueOf(valueOfDate[1]);
        int valueOfDay = Integer.valueOf(valueOfDate[0]);
        
        if (valueOfYear > 9999 || valueofMonth > 12 || valueOfDay > 31) {
            throw new IllegalValueException(ActivityDate.MESSAGE_ACTIVITYDATE_INVALID);
        }
    }
    
    /**
     * Checks if EndDate is after StartDate & EndTime is after startTime when creating event
     */
    public void validEventDate(ActivityDate startDate, ActivityTime startTime, ActivityDate endDate, ActivityTime endTime) throws IllegalValueException {
        
    	Boolean checkTime;
        String[] fromDate = startDate.toString().split("-");
        int fromYear = Integer.valueOf(fromDate[2]);
        int fromMonth = Integer.valueOf(fromDate[1]);
        int fromDay = Integer.valueOf(fromDate[0]);
        int fromTime = 0;
        if (startTime.toString().equals(ActivityTime.INFERRED_TIME)){
        	checkTime = false;
        }
        else {
        	checkTime = true;
        	fromTime = Integer.valueOf(startTime.toString());
        }

        String[] toDate = endDate.toString().split("-");
        int toYear = Integer.valueOf(toDate[2]);
        int toMonth = Integer.valueOf(toDate[1]);
        int toDay = Integer.valueOf(toDate[0]);
        int toTime = 0;
        if (!endTime.toString().equals(ActivityTime.INFERRED_TIME)){
        	toTime = Integer.valueOf(endTime.toString());
        }
        
        boolean sameDate = false;
        
        // Compare date
        if (fromYear > toYear) {
            throw new IllegalValueException(END_DATE_BEFORE_START_DATE_ERROR);
        }
        if (fromYear == toYear && fromMonth > toMonth) {
            throw new IllegalValueException(END_DATE_BEFORE_START_DATE_ERROR);
        }
        if (fromYear == toYear && fromMonth == toMonth && fromDay > toDay) {
            throw new IllegalValueException(END_DATE_BEFORE_START_DATE_ERROR);
		}
		
        if (fromYear == toYear && fromMonth == toMonth && fromDay == toDay) {
            sameDate = true;
        }
        
        if (sameDate) {
            // Compare time
			if (checkTime) {
				if (fromTime > toTime) {
					throw new IllegalValueException(END_DATE_BEFORE_START_DATE_ERROR);
				}
			}
        }
        return;
    }
    
}
```
###### \java\seedu\menion\logic\commands\CompleteCommand.java
``` java
public class CompleteCommand extends Command {

    public static final String COMMAND_WORD = "complete";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Completes an activity using their type and index: "
            + "\n" + "Parameters: [Activity_Type] + [Activity_Index] \n"
            + "Example: complete " + Activity.TASK_TYPE + " 1";
    public static final String MESSAGE_COMPLETED_ACTIVITY_SUCCESS = "Completed Activity: %1$s";
    public static final String MESSAGE_ALREADY_COMPLETED = "Menion has already completed this activity!";
    public static final String MESSAGE_EVENT_CANT_BE_COMPLETED = "Events do not need to be completed!";
    
    public final int targetIndex;
    public final String targetType;
    ReadOnlyActivity activityToComplete;

    public CompleteCommand(String[] splited) {
        
        assert splited != null;
        this.targetType = splited[1];
        this.targetIndex = Integer.valueOf(splited[2]) - 1;
    }

    @Override
    public CommandResult execute() {

    	assert model != null;
    	model.storePreviousState(new ActivityManager(model.getActivityManager()));
    	
        UnmodifiableObservableList<ReadOnlyActivity> lastShownList;
        try {
            if (targetType.equals(Activity.FLOATING_TASK_TYPE)) {
                lastShownList = model.getFilteredFloatingTaskList();
                activityToComplete = lastShownList.get(targetIndex);
            } else if (targetType.equals(Activity.TASK_TYPE)) {
                lastShownList = model.getFilteredTaskList();
                activityToComplete = lastShownList.get(targetIndex);
            } else {
                return new CommandResult(String.format(MESSAGE_EVENT_CANT_BE_COMPLETED, activityToComplete));
            }
        } catch (IndexOutOfBoundsException e) {
            return new CommandResult(Messages.MESSAGE_INVALID_ACTIVITY_DISPLAYED_INDEX);
        }
        
        if (lastShownList.size() <= targetIndex || targetIndex < 0) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_ACTIVITY_DISPLAYED_INDEX);
        }
        
        if (activityToComplete.getActivityStatus().status) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(MESSAGE_ALREADY_COMPLETED);
        }
        
        callCompleteActivity(targetType, activityToComplete); // Calls the correct method depending on type of activity.
        model.updateRecentChangedActivity(activityToComplete);
        return new CommandResult(String.format(MESSAGE_COMPLETED_ACTIVITY_SUCCESS, activityToComplete));
    }

    private void callCompleteActivity(String targetType, ReadOnlyActivity activityToComplete) {
        assert model != null;
        
        try {
            if (targetType.equals(Activity.FLOATING_TASK_TYPE)) {
                model.completeFloatingTask(activityToComplete);
            } else if (targetType.equals(Activity.TASK_TYPE)){
                model.completeTask(activityToComplete);
            } else {
                assert false: "Events do not need to be completed";
            }
        }catch (ActivityNotFoundException pnfe) {
            assert false : "The target activity cannot be missing";
        }
    }
}
```
###### \java\seedu\menion\logic\commands\EditCommand.java
``` java
public class EditCommand extends Command {

    public static final String COMMAND_WORD = "edit";
    public static final String INDEX_NOT_FOUND = "Menion cannot find the target activity in our lists, please use a valid index.";
    public static final String MESSAGE_EDITED_ACTIVITY_SUCCESS = "Menion edited your Activity to: %1$s";
    
    private final int targetIndex;
    private final String targetType;
    private final String changes;
    private final String newDate;
    private final String newTime;
    public final int paramToChange;
    
    ReadOnlyActivity activityToEdit;

    public EditCommand(String[] splited) {
        
        assert splited != null;
        this.targetType = splited[1];
        this.targetIndex = Integer.valueOf(splited[2]);
        this.paramToChange = Integer.valueOf(splited[3]);
        if (paramToChange >= 2 && !EditParser.taskToFloating) {
            // Only gets here, if User is editting Date and/or Time
            this.changes = null;
            this.newDate = splited[4];
            this.newTime = splited[5];
        }
        else {
            this.changes = splited[4];
            this.newDate = null;
            this.newTime = null;
        }
    }

    @Override
    public CommandResult execute() {
        
    	assert model != null;
    	
    	model.storePreviousState(new ActivityManager(model.getActivityManager()));
    	
        UnmodifiableObservableList<ReadOnlyActivity> lastShownList;
    	
        try {
            if (targetType.equals(Activity.FLOATING_TASK_TYPE)) {
                lastShownList = model.getFilteredFloatingTaskList();
                activityToEdit = lastShownList.get(targetIndex);
                floatingTaskEdit(activityToEdit, this.paramToChange);
            } else if (targetType.equals(Activity.TASK_TYPE)) {
                lastShownList = model.getFilteredTaskList();
                activityToEdit = lastShownList.get(targetIndex);
                taskEdit(activityToEdit, this.paramToChange);
            } else {
                lastShownList = model.getFilteredEventList();
                activityToEdit = lastShownList.get(targetIndex);
                eventEdit(activityToEdit, this.paramToChange);
            }
        } catch (IllegalValueException e) {
            return new CommandResult(e.getMessage());
        } catch (ActivityNotFoundException pnfe) {
            return new CommandResult(INDEX_NOT_FOUND);
        }
        
        // Validates valid index is an index of an activity in the correct list
        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_ACTIVITY_DISPLAYED_INDEX);
        }
        model.updateRecentChangedActivity(activityToEdit);
        return new CommandResult(String.format(MESSAGE_EDITED_ACTIVITY_SUCCESS, activityToEdit));
    }
    

    private void floatingTaskEdit(ReadOnlyActivity floatingTaskToEdit, int paramToChange) throws IllegalValueException, ActivityNotFoundException{
    	assert model != null;
    	
        switch (paramToChange) {

        case 0:
            String newName = this.changes;
            model.editFloatingTaskName(floatingTaskToEdit, newName);
            break;
        case 1:
            String newNote = this.changes;
            model.editFloatingTaskNote(floatingTaskToEdit, newNote);
            break;
        case 2:
            model.editTaskDateTime(floatingTaskToEdit, this.newDate, this.newTime);
            break;
        }
    }

    private void taskEdit(ReadOnlyActivity taskToEdit, int paramToChange) throws IllegalValueException, ActivityNotFoundException {
    	assert model != null;
    	
        switch (paramToChange) {

        case 0:
            String newName = this.changes;
            model.editTaskName(taskToEdit, newName);
            break;
        case 1:
            String newNote = this.changes;
            model.editTaskNote(taskToEdit, newNote);
            break;
        case 2:
            model.editTaskDateTime(taskToEdit, this.newDate, this.newTime);
            break;
        case 4:
            if (this.changes.contains(Activity.FLOATING_TASK_TYPE)) {
                   model.editTaskToFloating(taskToEdit);
            } else {
                throw new IllegalValueException("Menion can only accept changing task to: " + Activity.FLOATING_TASK_TYPE);
            }
        }
    }
    
    private void eventEdit(ReadOnlyActivity eventToEdit, int paramToChange) throws IllegalValueException , ActivityNotFoundException{
    	assert model != null;
    	
        switch (paramToChange) {

        case 0:
            String newName = this.changes;
            model.editEventName(eventToEdit, newName);
            break;
        case 1:
            String newNote = this.changes;
            model.editEventNote(eventToEdit, newNote);
            break;
        case 3: 
            model.editEventStartDateTime(eventToEdit, this.newDate, this.newTime);
            break;
        case 4:
            model.editEventEndDateTime(eventToEdit, this.newDate, this.newTime);
            break;
        }
    }
}
```
###### \java\seedu\menion\logic\commands\RemindCommand.java
``` java
public class RemindCommand extends Command {
    
    public static final String COMMAND_WORD = "remind";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Menion will automatically send you an email when you miss the deadline of a task!\n"
                                                            + "Example: " + COMMAND_WORD + " [Your email]";
    public static final String MESSAGE_REMINDER_SET_SUCCESS = "Reminders set!";
    public static final String MESSAGE_PROBLEM_ENCOUNTERED = "Oh no! Menion has encountered a problem, try restarting it";
    public static final String REMINDER_ON = "true";

    private String userEmail;
    
    public RemindCommand(String userEmail) {
        this.userEmail = userEmail;
    }

    @Override
    public CommandResult execute() {
        // Writes userEmail to a file.
        // Saves file
        PrintStream out;
        StringBuilder build = new StringBuilder();
        build.append(REMINDER_ON);
        build.append("\n");
      
        try {
            out = new PrintStream(new FileOutputStream(Messages.MESSAGE_FILE));
            build.append(this.userEmail);
            out.print(build.toString()); // puts the UserEmail into the txt file.
        } catch (FileNotFoundException e) {
            return new CommandResult(MESSAGE_PROBLEM_ENCOUNTERED);
        }
        return new CommandResult(MESSAGE_REMINDER_SET_SUCCESS);
    }
    
}
```
###### \java\seedu\menion\logic\commands\UnCompleteCommand.java
``` java
public class UnCompleteCommand extends Command {

    public static final String COMMAND_WORD = "uncomplete";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": UnCompletes an activity using their type and index: "
            + "\n"
            + "Parameters: [Activity_Type] + [Activity_Index] \n"
            + "Example: " + COMMAND_WORD + " " + Activity.EVENT_TYPE + " 1";
    public static final String MESSAGE_UNCOMPLETED_ACTIVITY_SUCCESS = "UnCompleted Activity: %1$s";
    public static final String MESSAGE_ALREADY_UNCOMPLETED = "Menion has already uncompleted this activity!";
    
    public final int targetIndex;
    public final String targetType;
    ReadOnlyActivity activityToUncomplete;
    
    public UnCompleteCommand(String[] splited) {
        
        assert splited != null;
        this.targetType = splited[1];
        this.targetIndex = Integer.valueOf(splited[2]) - 1;
    }

    @Override
    public CommandResult execute() {
        
        assert model != null;
        model.storePreviousState(new ActivityManager(model.getActivityManager()));
        
        UnmodifiableObservableList<ReadOnlyActivity> lastShownList;
        try {
            if (targetType.equals(Activity.FLOATING_TASK_TYPE)) {
                lastShownList = model.getFilteredFloatingTaskList();
                activityToUncomplete = lastShownList.get(targetIndex);
            }
            else {
                lastShownList = model.getFilteredTaskList();
                activityToUncomplete = lastShownList.get(targetIndex);
            }
        } catch (IndexOutOfBoundsException e) {
            return new CommandResult(Messages.MESSAGE_INVALID_ACTIVITY_DISPLAYED_INDEX);
        }
            
        if (lastShownList.size() <= targetIndex || targetIndex < 0) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_ACTIVITY_DISPLAYED_INDEX);
        }
        if (!activityToUncomplete.getActivityStatus().status) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(MESSAGE_ALREADY_UNCOMPLETED);
        }
        
        callUnCompleteActivity(targetType, activityToUncomplete); // Calls the correct method depending on type of activity.
        
        model.updateRecentChangedActivity(activityToUncomplete);
        
        return new CommandResult(String.format(MESSAGE_UNCOMPLETED_ACTIVITY_SUCCESS, activityToUncomplete));
    }

    private void callUnCompleteActivity(String targetType, ReadOnlyActivity activityToUncomplete) {
    	assert model != null;
        		
        try {
            if (targetType.equals(Activity.FLOATING_TASK_TYPE)) {
                model.UncompleteFloatingTask(activityToUncomplete);
            } else {
                model.UncompleteTask(activityToUncomplete);
            }
        }catch (ActivityNotFoundException pnfe) {
            assert false : "The target activity cannot be missing";
        }
    }
}
```
###### \java\seedu\menion\logic\commands\UnremindCommand.java
``` java
public class UnremindCommand extends Command {

    public static final String COMMAND_WORD = "unremind";
    public static final String REMINDER_OFF = "false";
    public static final String MESSAGE_REMINDER_UNSET_SUCCESS = "Reminders are unset! You will not be receiving anymore emails from Menion";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Menion will stop sending you notifications!\n"
            + "Example: " + COMMAND_WORD;
    public static final String REMIND_NOT_SET_ERROR = "Error! Menion cannot help you unset reminders if you have yet to set any!";

    @Override
    public CommandResult execute() {

        try {
            // Retrieve the email of the user from the txt file.
            Scanner fromFile = new Scanner(new File(Messages.MESSAGE_FILE));
            String isRemindOn = fromFile.next();
            if (isRemindOn.equals(REMINDER_OFF)) {
                return new CommandResult(REMIND_NOT_SET_ERROR);
            }
            fromFile.nextLine(); // Skips a line.
            String userEmail = fromFile.nextLine();
            
            // Writes userEmail to a file.
            // Saves file
            PrintStream out;
            StringBuilder build = new StringBuilder();
            build.append(REMINDER_OFF); // Turns off reminder
            build.append("\n");

            out = new PrintStream(new FileOutputStream(Messages.MESSAGE_FILE));
            build.append(userEmail);
            out.print(build.toString()); // puts the UserEmail into the txt file
        } catch (FileNotFoundException e) {
            return new CommandResult(REMIND_NOT_SET_ERROR);
        }
        return new CommandResult(MESSAGE_REMINDER_UNSET_SUCCESS);
    }

}
```
###### \java\seedu\menion\logic\parser\ActivityParser.java
``` java
        case CompleteCommand.COMMAND_WORD:
            return prepareComplete(arguments);
            
        case UnCompleteCommand.COMMAND_WORD:
            return prepareUnComplete(arguments);
        
        case EditCommand.COMMAND_WORD:
            return prepareEdit(arguments);
            
        case RemindCommand.COMMAND_WORD:
            return prepareRemind(arguments);
        
        case UnremindCommand.COMMAND_WORD:
            return prepareUnremind(arguments);
            
        case ModifyStoragePathCommand.COMMAND_WORD:
        	return new ModifyStoragePathCommand(arguments);
            
        case ExitCommand.COMMAND_WORD:
            return new ExitCommand();

        case HelpCommand.COMMAND_WORD:
            return new HelpCommand();

        default:
            return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
        }
    }
    
```
###### \java\seedu\menion\logic\parser\ActivityParser.java
``` java
    private Command prepareUnremind(String args) {
        String[] splited = args.split("\\s+");
        
        // Should only contain a space. No other arguments.
        if (splited.length != 1) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UnremindCommand.MESSAGE_USAGE));
        }
        
        return new UnremindCommand();
    }
    private Command prepareRemind(String args) {
        String[] splited = args.split("\\s+");
        
        // Should only contain a space, and Email of the user.
        if (splited.length != 2) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, RemindCommand.MESSAGE_USAGE));
        }
        // Checks that it is a valid email. Include regex here.
        
        return new RemindCommand(splited[1]);    
    }
    
    private Command prepareComplete(String args) {

        String[] splited = args.split("\\s+");
        
        // Should only contain a space, Activity Type and Index
        if (splited.length != 3) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, CompleteCommand.MESSAGE_USAGE));
        }
        
        // Checks that the activity type is of valid type
        boolean isValidType = false;
        String activityType = splited[1];

        if (activityType.equals(Activity.FLOATING_TASK_TYPE) || activityType.equals(Activity.TASK_TYPE) || activityType.equals(Activity.EVENT_TYPE)) {
            isValidType = true;
        }
        if (!isValidType) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, CompleteCommand.MESSAGE_USAGE));
        }

        Optional<Integer> index = Optional.of(Integer.valueOf(splited[2]));
        if(!index.isPresent()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, CompleteCommand.MESSAGE_USAGE));
        }
        
        return new CompleteCommand(splited);
    }
    
    private Command prepareUnComplete(String args) {

        String[] splited = args.split("\\s+");
        
        // Should only contain a space, Activity Type and Index
        if (splited.length != 3) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UnCompleteCommand.MESSAGE_USAGE));
        }
        
        boolean isValidType = false; // Checks that the activity type is of valid type
        String activityType = splited[1];

        if (activityType.equals(Activity.FLOATING_TASK_TYPE) || activityType.equals(Activity.TASK_TYPE) || activityType.equals(Activity.EVENT_TYPE)) {
            isValidType = true;
        }
        if (!isValidType) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, CompleteCommand.MESSAGE_USAGE));
        }

        Optional<Integer> index = Optional.of(Integer.valueOf(splited[2]));

        if(!index.isPresent()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, CompleteCommand.MESSAGE_USAGE));
        }

        return new UnCompleteCommand(splited);
    }
    
    private Command prepareEdit(String args) {
        try {
            return new EditCommand(EditParser.parseEditCommand(args));
        } catch (IllegalValueException e) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, e.getMessage()));
        }
    }
    
```
###### \java\seedu\menion\logic\parser\EditParser.java
``` java
public class EditParser {

    public static final String NAME_PARAM = "name:";
    public static final String NOTE_PARAM = "n:";
    public static final String TASK_DEADLINE_PARAM = "by:";
    public static final String EVENT_FROM_PARAM = "from:";
    public static final String EVENT_TO_PARAM = "to:";
    public static final String SEPARATOR = "/ ";
    public static final String MESSAGE_INVALID_PARAMETER = "Menion detected an invalid parameter for the current type! \n" +
            "Please make sure it is, for: \n" + 
            Activity.FLOATING_TASK_TYPE + ": "  + NAME_PARAM + SEPARATOR + NOTE_PARAM + SEPARATOR + TASK_DEADLINE_PARAM + "\n" +
            Activity.TASK_TYPE + ": " + NAME_PARAM + SEPARATOR + NOTE_PARAM + SEPARATOR + TASK_DEADLINE_PARAM + "\n" +
            Activity.EVENT_TYPE + ": " + NAME_PARAM + SEPARATOR + NOTE_PARAM + SEPARATOR + EVENT_FROM_PARAM + SEPARATOR + EVENT_TO_PARAM;

    public static final String MESSAGE_USAGE = EditCommand.COMMAND_WORD
            + ": edit an activity using their type, index, [Parameters to change] and new changes: " + "\n"
            + "Parameters: [Activity_Type] + [Activity_Index] [ '"+NAME_PARAM+"', '"+NOTE_PARAM+"', '"+TASK_DEADLINE_PARAM+" (Date & Time)', '"+EVENT_FROM_PARAM+" (Date & Time)' '"+EVENT_TO_PARAM+" (Date & Time)' ] + [Changes]\n"
            + "Example: " + EditCommand.COMMAND_WORD + " task 1 by: 10-10-2016 1900 \n" 
            + "Example: " + EditCommand.COMMAND_WORD+ " task 1 n: write in red ink \n" 
            + "Example: " + EditCommand.COMMAND_WORD + " event 1 name: ORD";

    UnmodifiableObservableList<ReadOnlyActivity> lastShownList; // List of all current activities.
    public static String[] editDetails = new String[6];
    private static ArrayList<String> fromNatty = new ArrayList<String>();
    public static boolean taskToFloating;
    
    public static String[] parseEditCommand(String details) throws IllegalValueException {
        
        String[] input = details.split("\\s+");

        // Checks for valid number of parameters.
        // Must be 5 and above. [Command] + [Type] + [index] + [parameter] + [changes]
        if (input.length <= 4) {
            throw new IllegalValueException(MESSAGE_USAGE);
        }

        // Checks for valid activityType
        String activityType = input[1];
        validActivityType(activityType);
        editDetails[1] = activityType;
        
        // Checks for presence of index 
        int targetIndex = Integer.valueOf(input[2]) - 1;
        validIndex(targetIndex);
        editDetails[2] = String.valueOf(targetIndex); // replace with verified index
        
        // Checks for paramToChange
        String indexOfParam = String.valueOf(checkParam(input[3], activityType));
        editDetails[3] = indexOfParam; // Replace with an index for editCommand to check.
        editDetails[4] = arrayToString(Arrays.copyOfRange(input, 4, input.length));
        
        // Parse the changes with natty, if required to
        // From indexOfParam 2 -> 5. It requires Natty to parse Date & Time. 0, and 1 is simply Name and note.
        taskToFloating = changeTaskToFloating(activityType, indexOfParam);
        if (Integer.valueOf(indexOfParam) >= 2 && !taskToFloating) {
            NattyDateParser.parseDate(editDetails[4], fromNatty);
            editDetails[4] = fromNatty.get(0);
            editDetails[5] = fromNatty.get(1);
        } else {
            // Do nothing. No changes to be made.
        }
        // If indexOfParam is >= 2. Implies user is changing date & Time.
        return editDetails;
    }

    private static void validActivityType(String typeToCheck) throws IllegalValueException {
        
        if (typeToCheck.equals(Activity.FLOATING_TASK_TYPE) || typeToCheck.equals(Activity.TASK_TYPE) 
                || typeToCheck.equals(Activity.EVENT_TYPE)) {  
            return;
        } else {
            throw new IllegalValueException(MESSAGE_INVALID_PARAMETER);
        }
    }
    
    private static void validIndex(int targetIndex) throws IllegalValueException {
        
        Optional<Integer> index = Optional.of(targetIndex);
        if (index.isPresent()){
            return;
        } else {
            throw new IllegalValueException(MESSAGE_INVALID_PARAMETER);
        }
    }
    
    /**
     * 
     * @param paramToChange
     * @return an integer to match with the param to change, refer below for index:
     *         0 = name (For all) 
     *         1 = note (For all) 
     *         2 = by (For Tasks only, and floating Task) 
     *         3 = from (For Event's Start Date & Time)
     *         4 = to (For Event's End Date & Time)
     */
    private static int checkParam(String paramToChange, String activityType) throws IllegalValueException {

        if (paramToChange.equals(NAME_PARAM)) {
            return 0;
        } else if (paramToChange.equals(NOTE_PARAM)) {
            return 1;
        } else if (paramToChange.equals(TASK_DEADLINE_PARAM) && (activityType.equals(Activity.TASK_TYPE) || (activityType.equals(Activity.FLOATING_TASK_TYPE)))) {
            return 2;
        } else if (paramToChange.equals(EVENT_FROM_PARAM) && activityType.equals(Activity.EVENT_TYPE)) {
            return 3;
        } else if (paramToChange.equals(EVENT_TO_PARAM) && (activityType.equals(Activity.EVENT_TYPE) || activityType.equals(Activity.TASK_TYPE))) {
            return 4;
        }
        throw new IllegalValueException(MESSAGE_INVALID_PARAMETER);
    }

    private static String arrayToString(String[] from) {
        StringBuilder build = new StringBuilder();
        
        for (int i = 0; i < from.length; i++) {
            build.append(from[i]);
            build.append(" ");
        }
        return build.toString();
    }
    
    /**
     *  This is a unique case of edit. Where we change Task -> FloatingTask. 
     *  returns true if Activity type is: "Task" & indexOfParam is "to:" 
     */
    private static boolean changeTaskToFloating(String activityType, String indexOfParam) {
        if (activityType.equals(Activity.TASK_TYPE) && Integer.valueOf(indexOfParam) == 4) {
            return true;
        } else {
            return false;
        }
    }
}
```
###### \java\seedu\menion\model\activity\Activity.java
``` java
public class Activity implements ReadOnlyActivity {

    // Types of Activity
    public static final String FLOATING_TASK_TYPE = "floating";
    public static final String TASK_TYPE = "task";
    public static final String EVENT_TYPE = "event";

    public static final Integer FLOATING_TASK_LENGTH = 3; // ActivityType,
                                                          // ActivityName, Note
    public static final Integer TASK_LENGTH = 5; // ActivityType, Note,
                                                 // ActivityName StartDate,
                                                 // StartTime
    public static final Integer EVENT_LENGTH = 7; // ActivityType, Note,
                                                  // ActivityName, StartDate,
                                                  // StartTime, EndDate, EndTime

    // Indexes of the parameters to retrieve from the constructor.
    public static final Integer INDEX_ACTIVITY_TYPE = 0;
    public static final Integer INDEX_ACTIVITY_NAME = 1;
    public static final Integer INDEX_ACTIVITY_NOTE = 2;
    public static final Integer INDEX_ACTIVITY_STARTDATE = 3;
    public static final Integer INDEX_ACTIVITY_STARTTIME = 4;
    public static final Integer INDEX_ACTIVITY_ENDDATE = 5;
    public static final Integer INDEX_ACTIVITY_ENDTIME = 6;

    private ActivityName name;
    private ActivityDate startDate;
    private ActivityTime startTime;
    private ActivityDate endDate;
    private ActivityTime endTime;
    private Note note;
    private String activityType;
    private Completed status;
    private Boolean emailSent;
    private Boolean activityTimePassed;
    private Boolean eventOngoing;

    // Every Activity Object will have an array list of it's details for ease of
    // accessibility
    private ArrayList<String> activityDetails;

    /**
     * For floatingTask Every field must be present and not null.
     */
    public Activity(String type, ActivityName name, Note note, Completed status) {
        this.activityType = type;
        this.name = name;
        this.note = note;
        this.status = status;
        setActivityDetails();
    }

    /**
     * For Task Every field must be present and not null.
     */
    public Activity(String type, ActivityName name, Note note, ActivityDate startDate, ActivityTime startTime,
            Completed status, Boolean activityTimePassed, Boolean emailSent) {
        
        this.activityType = type;
        this.name = name;
        this.note = note;
        this.startDate = startDate;
        this.startTime = startTime;
        this.status = status;
        if (activityTimePassed == null) {
            this.activityTimePassed = false;
        } else {
            this.activityTimePassed = activityTimePassed;
        }
        if (emailSent == null) {
            this.emailSent = false;
        } else {
            this.emailSent = emailSent;
        }

        setActivityDetails();
    }

    /**
     * For Event Every field must be present and not null.
     */
    public Activity(String type, ActivityName name, Note note, ActivityDate startDate, ActivityTime startTime,
            ActivityDate endDate, ActivityTime endTime, Completed status, Boolean activityTimePassed,
            Boolean eventOngoing) {

        this.activityType = type;
        this.name = name;
        this.note = note;
        this.startDate = startDate;
        this.startTime = startTime;
        this.endDate = endDate;
        this.endTime = endTime;
        this.status = status;
        if (activityTimePassed == null) {
            this.activityTimePassed = false;
        } else {
            this.activityTimePassed = activityTimePassed;
        }
        if (eventOngoing == null) {
            this.eventOngoing = false;
        } else {
            this.eventOngoing = eventOngoing;
        }

        setActivityDetails();
    }

    /**
     * Copy constructor.
     */
    public Activity(ReadOnlyActivity source) {

        if (source.getActivityType().equals(FLOATING_TASK_TYPE)) {
            activityType = source.getActivityType();
            name = source.getActivityName();
            note = source.getNote();
            status = source.getActivityStatus();
        } else if (source.getActivityType().equals(TASK_TYPE)) {
            activityType = source.getActivityType();
            ;
            name = source.getActivityName();
            note = source.getNote();
            startDate = source.getActivityStartDate();
            startTime = source.getActivityStartTime();
            status = source.getActivityStatus();
            emailSent = source.isEmailSent();
            activityTimePassed = source.isTimePassed();
        } else if (source.getActivityType().equals(EVENT_TYPE)) {
            activityType = source.getActivityType();
            ;
            name = source.getActivityName();
            note = source.getNote();
            startDate = source.getActivityStartDate();
            startTime = source.getActivityStartTime();
            endDate = source.getActivityEndDate();
            endTime = source.getActivityEndTime();
            status = source.getActivityStatus();
            activityTimePassed = source.isTimePassed();
            eventOngoing = source.isEventOngoing();

        }
        this.status = source.getActivityStatus();
        this.activityDetails = source.getActivityDetails();
    }

    // Creates a unique ArrayList of details for each activity.
    @Override
    public void setActivityDetails() {
        
        if (activityType.equals(FLOATING_TASK_TYPE)) {
            activityDetails = new ArrayList<String>(FLOATING_TASK_LENGTH);
            activityDetails.add(activityType);
            activityDetails.add(name.toString());
            activityDetails.add(note.toString());
            activityDetails.add(status.toString());
        } else if (activityType.equals(TASK_TYPE)) {
            activityDetails = new ArrayList<String>(TASK_LENGTH);
            activityDetails.add(activityType);
            activityDetails.add(name.toString());
            activityDetails.add(note.toString());
            activityDetails.add(startDate.toString());
            activityDetails.add(startTime.toString());
            activityDetails.add(status.toString());
        } else if (activityType.equals(EVENT_TYPE)) {
            activityDetails = new ArrayList<String>(EVENT_LENGTH);
            activityDetails.add(activityType);
            activityDetails.add(name.toString());
            activityDetails.add(note.toString());
            activityDetails.add(startDate.toString());
            activityDetails.add(startTime.toString());
            activityDetails.add(endDate.toString());
            activityDetails.add(endTime.toString());
            activityDetails.add(status.toString());
        }
    }

    /**
     * @throws IllegalValueException
     * List of methods to set Activity's param : Type, Name, Note,
     * startDate, startTime, completion status, emailSent status,
     * timePassed status.
     */
    @Override
    public void setActivityType(String newType) throws IllegalValueException {
        
        if (!newType.equals(FLOATING_TASK_TYPE) && !newType.equals(TASK_TYPE) && !newType.equals(EVENT_TYPE)) {
            throw new IllegalValueException(Messages.MESSAGE_INVALID_TYPE);
        } else {
            this.activityType = newType;
        }
    }

    @Override
    public void setActivityName(String newName) throws IllegalValueException {
        
        assert (newName != null);
        this.name = new ActivityName(newName);
    }

    @Override
    public void setActivityNote(String newNote) throws IllegalValueException {
        
        assert (newNote != null);
        this.note = new Note(newNote);
    }

    // Only can be called by Task & Events
    @Override
    public void setActivityStartDateTime(String newDate, String newTime) throws IllegalValueException {

        boolean isEvent = this.activityType.equals(Activity.EVENT_TYPE);
        ActivityDate newDateObject = new ActivityDate(newDate);
        ActivityTime newTimeObject = new ActivityTime(newTime);
        if (isEvent) {
            DateChecker check = new DateChecker();
            check.validEventDate(newDateObject, newTimeObject, this.endDate, this.endTime);
        }
        this.startDate = newDateObject;
        this.startTime = newTimeObject;

    }

    @Override
    public void setActivityEndDateTime(String newDate, String newTime) throws IllegalValueException {
        
        boolean isEvent = this.activityType.equals(Activity.EVENT_TYPE);
        DateChecker check = new DateChecker();
        assert (isEvent);
        ActivityDate newDateObject = new ActivityDate(newDate);
        ActivityTime newTimeObject = new ActivityTime(newTime);
        check.validEventDate(this.startDate, this.startTime, newDateObject, newTimeObject);
        this.endDate = newDateObject;
        this.endTime = newTimeObject;
    }

    @Override
    public void setCompleted() {
        this.status = new Completed(true);
    }

    @Override
    public void setUncompleted() {
        this.status = new Completed(false);
    }

    public void setTimePassed(Boolean timePassed) {
        this.activityTimePassed = timePassed;
    }

    public void setEventOngoing(Boolean eventOngoing) {
        this.eventOngoing = eventOngoing;
    }

    public void setEmailSent(Boolean sentStatus) {
        this.emailSent = sentStatus;
    }

    /**
     * Getter methods for Activity, returns all possible params of activity.
     */
    @Override
    public Completed getActivityStatus() {
        return this.status;
    }

    @Override
    public ActivityName getActivityName() {
        return this.name;
    }

    @Override
    public Note getNote() {
        return this.note;
    }

    @Override
    public ActivityDate getActivityStartDate() {
        return this.startDate;
    }

    @Override
    public ActivityTime getActivityStartTime() {
        return this.startTime;
    }

    @Override
    public ActivityDate getActivityEndDate() {
        return this.endDate;
    }

    @Override
    public ActivityTime getActivityEndTime() {
        return this.endTime;
    }

    @Override
    public String getActivityType() {
        return this.activityType;
    }

    /**
     * returns the arrayList consisting of an activity's details.
     */
    @Override
    public ArrayList<String> getActivityDetails() {
        return activityDetails;
    }

    public Boolean isEmailSent() {
        return this.emailSent;
    }

    public Boolean isTimePassed() {
        return this.activityTimePassed;
    }

    public Boolean isEventOngoing() {
        return this.eventOngoing;
    }

    @Override
    public Activity get() {
        return this;
    }

    @Override
    public String toString() {
        
        switch (this.activityType) {
        case FLOATING_TASK_TYPE:
            return getFloatingTaskAsText();
        case TASK_TYPE:
            return getTaskAsText();
        case EVENT_TYPE:
            return getEventAsText();
        }
        return null;
    }

```
###### \java\seedu\menion\model\activity\ActivityDate.java
``` java
public class ActivityDate {


    public static final String MESSAGE_ACTIVITYDATE_CONSTRAINTS = "Activity date should be in dd-mm-yyyy format";

    public static final String MESSAGE_ACTIVITYDATE_INVALID = "Oh no! Menion has detected an invalid date! Please ensure that day-month-year is valid";

    public static final String ACTIVITYDATE_VALIDATION_REGEX = "(0?[0-3][0-9]-[0-1][0-9]-[0-2][0-9][0-9][0-9])";

    public final String value;
    public final String formattedValue;
    private String month;

    /**
     * Validates given date.
     *
     * @throws IllegalValueException if given date string is invalid.
     */
    public ActivityDate(String date) throws IllegalValueException {
        
        assert date != null;
        date = date.trim();
        extractMonth(date);
        this.formattedValue = formatNiceDate(date);
        this.value = date;
    }

```
###### \java\seedu\menion\model\activity\ActivityName.java
``` java
public class ActivityName {

    public static final String MESSAGE_NAME_CONSTRAINTS = "Please limit the name of your activity to 40 characters.";
    public final String fullName;

    /**
     * Validates given name.
     *
     * @throws IllegalValueException if given name string is invalid.
     */
    public ActivityName(String name) throws IllegalValueException {
        
        assert name != null;
        name = name.trim();
        if (!isValidName(name)) {
            throw new IllegalValueException(MESSAGE_NAME_CONSTRAINTS);
        }
        this.fullName = name;
    }

    /**
     * Returns true if the input name is less than 140 characters.
     */
    public static boolean isValidName(String test) {
        
    	if (test.length() > 40){
    		return false;
    	}
    	
    	return true;
    }


    @Override
    public String toString() {
        return fullName;
    }

    @Override
    public boolean equals(Object other) {
        
        return other == this // short circuit if same object
                || (other instanceof ActivityName // instanceof handles nulls
                && this.fullName.equals(((ActivityName) other).fullName)); // state check
    }

    @Override
    public int hashCode() {
        return fullName.hashCode();
    }

}
```
###### \java\seedu\menion\model\activity\ActivityTime.java
``` java
public class ActivityTime {

    public static final String ACTIVITY_TIME_CONSTRAINTS = "Activity time should be in 24-hour format";
    public static final String ACTIVITY_TIME_VALIDATION_REGEX = "^[0-2][0-9][0-6][0-9]$";
    public static final String INFERRED_TIME = "";
    
    public final String value;
    /**
     * Validates given time date.
     *
     * @throws IllegalValueException if given time date string is invalid.
     */
    public ActivityTime(String time) throws IllegalValueException {
        assert time != null;
        time = time.trim();
        this.value = time;
    }

    /**
     * Returns if a given string is a valid activity time.
     */
    public static void isValidTime(String test) throws IllegalValueException  {
        
        DateChecker timeCheck = new DateChecker();
        
        // Checks that time has no illegal arguments
        if (!test.matches(ACTIVITY_TIME_VALIDATION_REGEX)) {
            throw new IllegalValueException(ACTIVITY_TIME_CONSTRAINTS);
        }
        // Checks time is between 0000 and 2400
        timeCheck.validTime(test);
        
        return;
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ActivityTime // instanceof handles nulls
                && this.value.equals(((ActivityTime) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

}
```
###### \java\seedu\menion\model\activity\Completed.java
``` java
public class Completed {
    
    public static final String COMPLETED_ACTIVITY = "Completed";
    public static final String UNCOMPLETED_ACTIVITY = "Uncompleted";
    public boolean status;
    
    /**
     * Constructor for a Completed, takes in new boolean as status.
     */
    public Completed(boolean complete) {
        this.status = complete;
    }
    
    // Constructor for Completed, using String
    public Completed(String status) {
        
        assert(status != null);
        if (status.equals(COMPLETED_ACTIVITY)) {
            this.status = true;
        }
        else if (status.equals(UNCOMPLETED_ACTIVITY)) {
            this.status = false;
        }
    }
    
    @Override
    public String toString() {
        
        if (status) {
            return COMPLETED_ACTIVITY;
        }
        else {
            return UNCOMPLETED_ACTIVITY;
        }
    }
    
    public void complete() {
        this.status = true;
    }
}
```
###### \java\seedu\menion\model\activity\Note.java
``` java
public class Note {
    
    public String value = "-";

    /**
     * Constructor for a note, takes in new String as note.
     */
    public Note(String note) throws IllegalValueException {
        
        assert note != null;
        this.value = note;
    }
    
    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        
        return other == this // short circuit if same object
                || (other instanceof Note // instanceof handles nulls
                && this.value.equals(((Note) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

}
```
###### \java\seedu\menion\model\activity\ReadOnlyActivity.java
``` java
    /**
     * Methods to set the Activity's Param 
     * @param the String of the new change to make.
     */
    void setCompleted();
    void setUncompleted();
    void setActivityType(String newType) throws IllegalValueException;
    void setActivityName(String newName) throws IllegalValueException;
    void setActivityNote(String newNote) throws IllegalValueException;
    void setActivityStartDateTime(String newDate, String newTime) throws IllegalValueException;
    void setActivityEndDateTime(String newDate, String newTime) throws IllegalValueException;
    void setEmailSent(Boolean sentStatus);
    void setTimePassed(Boolean timePassed);
    void setEventOngoing(Boolean eventOngoing);
    
    /**
     * For Floating Task
     * Only checks for: Name, Note
     * Returns true if both have the same state. (interfaces cannot override .equals)
     */
    default boolean isFloatingTaskSameStateAs(ReadOnlyActivity other) {
        
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                && other.getActivityName().equals(this.getActivityName())); // state checks here onwards
    }

    /**
     * For Task
     * Only checks for: Name, StartDate, StartTime & Note.
     * Returns true if both have the same state. (interfaces cannot override .equals)
     */
    default boolean isTaskSameStateAs(ReadOnlyActivity other) {
        
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                && other.getActivityName().equals(this.getActivityName()) // state checks here onwards
                && other.getActivityStartDate().equals(this.getActivityStartDate())
                && other.getActivityStartTime().equals(this.getActivityStartTime()));
    }

    /**
     * For Event
     * Only checks for: Name, StartDate, StartTime, EndDate, EndTime & Note.
     * Returns true if both have the same state. (interfaces cannot override .equals)
     */
    default boolean isEventSameStateAs(ReadOnlyActivity other) {
        
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                && other.getActivityName().equals(this.getActivityName()) // state checks here onwards
                && other.getActivityStartDate().equals(this.getActivityStartDate())
                && other.getActivityStartTime().equals(this.getActivityStartTime())
                && other.getActivityEndDate().equals(this.getActivityEndDate())
                && other.getActivityEndTime().equals(this.getActivityEndTime()));
    }
    
    /**
     * For Floating Task
     * Formats the Activity as text, showing all activity details.
     */
    default String getFloatingTaskAsText() {
        
        final StringBuilder builder = new StringBuilder();
        if (getNote().equals(null)){
        	builder.append(getActivityName())
        			.append("\nCompletion status: ")
        			.append(getActivityStatus().toString());
        	return builder.toString();
        }
		else {
			builder.append(getActivityName())
					.append("\nNote: ")
					.append(getNote())
					.append("\nCompletion status: ")
					.append(getActivityStatus().toString());
			return builder.toString();
		}
    }
    
    /**
     * For Task
     * Formats the Activity as text, showing all activity details.
     */
    default String getTaskAsText() {
        
        final StringBuilder builder = new StringBuilder();
        builder.append(getActivityName())
                .append("\nDeadline: ")
                .append(getActivityStartDate().toFormattedDateString());
        if (!getActivityStartTime().toString().equals(ActivityTime.INFERRED_TIME)){
        	builder.append(", ")
        			.append(getActivityStartTime());
        }
        if (getNote().toString() != null){
        	builder.append("\nNote: ")
        			.append(getNote());
        }
       builder.append("\nCompletion status: ")
       			.append(getActivityStatus().toString());

        return builder.toString();
    }
    
    /**
     * For Event
     * Formats the Activity as text, showing all activity details.
     */
    default String getEventAsText() {
        
        final StringBuilder builder = new StringBuilder();
        
        builder.append(getActivityName())
        		.append("\nStarting from: ")
        		.append(getActivityStartDate().toFormattedDateString());
        
        if (!getActivityStartTime().toString().equals(ActivityTime.INFERRED_TIME)){
        	builder.append(", ")
			.append(getActivityStartTime());
        }
        
        builder.append("\nEnding at: ")
        		.append(getActivityEndDate().toFormattedDateString());
        
        if (!getActivityStartTime().toString().equals(ActivityTime.INFERRED_TIME)){
        	builder.append(",  ")
			.append(getActivityEndTime());
        }
        
        if (getNote().toString() != null){
        	builder.append("\nNote: ")
        			.append(getNote());
        }
        
        builder.append("\nCompletion status: ")
        		.append(getActivityStatus().toString());
        
        return builder.toString();
    }
}
```
###### \java\seedu\menion\model\ActivityManager.java
``` java
    /**
     * Methods, Completes an activity in the activity manager.
     * Passes in the index of the list to complete
     * 
     * @param activityToComplete
     */
    public void completeTask(ReadOnlyActivity activityToComplete) throws ActivityNotFoundException {
        
        Activity dub = (Activity)activityToComplete;
        dub.setCompleted();
        tasks.getInternalList().set(tasks.getIndexOf(activityToComplete), dub);  
        Collections.sort(tasks.getInternalList(), new TaskComparator());
    }

    public void completeFloatingTask(ReadOnlyActivity activityToComplete) throws ActivityNotFoundException {
        
        Activity dub = (Activity)activityToComplete;
        dub.setCompleted();
        floatingTasks.getInternalList().set(floatingTasks.getIndexOf(activityToComplete), dub);
        Collections.sort(floatingTasks.getInternalList(), new FloatingTaskComparator());
    }
    
    /**
     * Methods, UnCompletes an activity in the activity manager.
     * Passes in the index of the list to complete
     * @param activityToUncomplete
     */
    public void unCompleteFloatingTask(ReadOnlyActivity activityToUncomplete) throws ActivityNotFoundException {
        
        Activity dub = (Activity)activityToUncomplete;
        dub.setUncompleted();
        floatingTasks.getInternalList().set(floatingTasks.getIndexOf(activityToUncomplete), dub);
        Collections.sort(floatingTasks.getInternalList(), new FloatingTaskComparator());
    }
    
    public void unCompleteTask(ReadOnlyActivity activityToUncomplete) throws ActivityNotFoundException {
        
        Activity dub = (Activity)activityToUncomplete;
        dub.setUncompleted();
        tasks.getInternalList().set(tasks.getIndexOf(activityToUncomplete), dub);
        Collections.sort(tasks.getInternalList(), new TaskComparator());
    }
    
    /**
     * Methods, edits an activity's NAME in the activity manager.
     * Passes in the index of the list to complete, and changes to make
     * @param floatingTaskToEdit
     * @throws IllegalValueException 
     */
    public void editFloatingTaskName(ReadOnlyActivity floatingTaskToEdit, String changes) throws IllegalValueException, ActivityNotFoundException {
        
        Activity dub = (Activity)floatingTaskToEdit;
        dub.setActivityName(changes);
        floatingTasks.getInternalList().set(floatingTasks.getIndexOf(floatingTaskToEdit), dub);
        Collections.sort(floatingTasks.getInternalList(), new FloatingTaskComparator());
    }
    
    public void editTaskName(ReadOnlyActivity taskToEdit, String changes) throws IllegalValueException, ActivityNotFoundException {
        
        Activity dub = (Activity)taskToEdit;
        dub.setActivityName(changes);
        tasks.getInternalList().set(tasks.getIndexOf(taskToEdit), dub); 
        Collections.sort(tasks.getInternalList(), new TaskComparator());
    }
    
    public void editEventName(ReadOnlyActivity eventToEdit, String changes) throws IllegalValueException, ActivityNotFoundException {
        Activity dub = (Activity)eventToEdit;
        dub.setActivityName(changes);
        events.getInternalList().set(events.getIndexOf(eventToEdit), dub);   
        Collections.sort(events.getInternalList(), new EventComparator());
    }
    
    /**
     * Methods, edits an activity's NOTE in the activity manager.
     * Passes in the index of the list to complete, and changes to make
     * @param floatingTaskToEdit
     * @throws IllegalValueException 
     */
    public void editFloatingTaskNote(ReadOnlyActivity floatingTaskToEdit, String changes) throws IllegalValueException, ActivityNotFoundException {
        
        Activity dub = (Activity)floatingTaskToEdit;
        dub.setActivityNote(changes);
        floatingTasks.getInternalList().set(floatingTasks.getIndexOf(floatingTaskToEdit), dub);
    }
    
    public void editTaskNote(ReadOnlyActivity taskToEdit, String changes) throws IllegalValueException, ActivityNotFoundException {
        
        Activity dub = (Activity)taskToEdit;
        dub.setActivityNote(changes);
        tasks.getInternalList().set(tasks.getIndexOf(taskToEdit), dub); 
    }
    
    public void editEventNote(ReadOnlyActivity eventToEdit, String changes) throws IllegalValueException, ActivityNotFoundException {
        
        Activity dub = (Activity)eventToEdit;
        dub.setActivityNote(changes);
        events.getInternalList().set(events.getIndexOf(eventToEdit), dub);
    }
    
    /**
     * Methods, edits a Activity's starting Date & Time in the activity manager.
     * Passes in the index of the list to complete, and changes to make
     * @param taskToEdit
     * @throws IllegalValueException 
     * @throws ActivityNotFoundException 
     */
    public void editTaskToFloating(ReadOnlyActivity taskToEdit) throws IllegalValueException, ActivityNotFoundException {
        
        ActivityName name = taskToEdit.getActivityName();
        Note note = taskToEdit.getNote();
        Completed status = taskToEdit.getActivityStatus();
        Activity dub = new Activity(Activity.FLOATING_TASK_TYPE, name, note, status);
        removeTask(taskToEdit);
        addFloatingTask(dub);
    }
    
    public void editTaskDateTime(ReadOnlyActivity taskToEdit, String newDate, String newTime) throws IllegalValueException, ActivityNotFoundException {
        
        Activity dub = (Activity)taskToEdit;
        dub.setActivityStartDateTime(newDate, newTime);
        // Check if the task is overdue/not overdue after an edit.
        Calendar currentTime = Calendar.getInstance();
        
        // Only goes into this conditional statement if it is overdue.
        if (BackgroundCheckManager.isActivityOver(currentTime, taskToEdit)) {
            dub.setTimePassed(true);
        } else {
            // Not overdue.
            dub.setTimePassed(false);
            dub.setEmailSent(false);
        }
        // It is a FloatingTask changing to a Task
        // Removes the floatingTask from it's panel and adds it to Task panel
        if (taskToEdit.getActivityType().equals(Activity.FLOATING_TASK_TYPE)) {
            removeFloatingTask(taskToEdit);
            dub.setActivityType(Activity.TASK_TYPE);
            addTask(dub);
            return;
        }
        tasks.getInternalList().set(tasks.getIndexOf(taskToEdit), dub); 
        Collections.sort(tasks.getInternalList(), new TaskComparator());
    }

    public void editEventStartDateTime(ReadOnlyActivity eventToEdit, String newDate, String newTime) throws IllegalValueException, ActivityNotFoundException {
        
        Activity dub = (Activity)eventToEdit;
        dub.setActivityStartDateTime(newDate, newTime);
        events.getInternalList().set(events.getIndexOf(eventToEdit), dub);
        Collections.sort(events.getInternalList(), new EventComparator());
    }
    
    public void editEventEndDateTime(ReadOnlyActivity eventToEdit, String newDate, String newTime) throws IllegalValueException, ActivityNotFoundException {  
        
        Activity dub = (Activity)eventToEdit;
        dub.setActivityEndDateTime(newDate, newTime);
        events.getInternalList().set(events.getIndexOf(eventToEdit), dub);
    }
    
```
###### \java\seedu\menion\model\Model.java
``` java
    /** Completes the given Activity, given it's index. */
    void completeFloatingTask(ReadOnlyActivity activityToComplete) throws ActivityNotFoundException;
    void completeTask(ReadOnlyActivity activityToComplete) throws ActivityNotFoundException;
    
    /** Uncompletes the given Activity, given it's index. */
    void UncompleteFloatingTask(ReadOnlyActivity activityToUncomplete) throws ActivityNotFoundException;
    void UncompleteTask(ReadOnlyActivity activityToUncomplete) throws ActivityNotFoundException;
 
    /** 
     * Edits the name of the given Activity, given it's index. @throws IllegalValueException 
     */
    void editFloatingTaskName(ReadOnlyActivity floatingTaskToEdit, String changes) throws IllegalValueException, ActivityNotFoundException;
    void editTaskName(ReadOnlyActivity taskToEdit, String changes) throws IllegalValueException, ActivityNotFoundException;
    void editEventName(ReadOnlyActivity eventToEdit, String changes) throws IllegalValueException, ActivityNotFoundException;
    
    /**
     * Edits the note of the given Activity, given it's index @throws IllegalValueException 
     */
    void editFloatingTaskNote(ReadOnlyActivity floatingTaskToEdit, String changes) throws IllegalValueException, ActivityNotFoundException;
    void editTaskNote(ReadOnlyActivity taskToEdit, String changes) throws IllegalValueException, ActivityNotFoundException;
    void editEventNote(ReadOnlyActivity eventToEdit, String changes) throws IllegalValueException, ActivityNotFoundException;
    
    /**
     * Edits the Start Date & Time of the given Task/Event, given it's index @throws IllegalValueException 
     */
    void editTaskToFloating(ReadOnlyActivity taskToEdit) throws IllegalValueException, ActivityNotFoundException;
    void editTaskDateTime(ReadOnlyActivity taskToEdit, String newDate, String newTime) throws IllegalValueException, ActivityNotFoundException;
    void editEventEndDateTime(ReadOnlyActivity eventToEdit, String newDate, String newTime) throws IllegalValueException, ActivityNotFoundException;
    void editEventStartDateTime(ReadOnlyActivity eventToEdit, String newDate, String newTime) throws IllegalValueException, ActivityNotFoundException;
    
```
###### \java\seedu\menion\model\ModelManager.java
``` java
    /**
     * Methods for Completing an activity
     */
    @Override
    public void completeFloatingTask(ReadOnlyActivity activityToComplete) throws ActivityNotFoundException {
        
        activityManager.completeFloatingTask(activityToComplete);
        indicateActivityManagerChanged();
    }
    
    @Override
    public void completeTask(ReadOnlyActivity activityToComplete) throws ActivityNotFoundException {
        
        activityManager.completeTask(activityToComplete);
        indicateActivityManagerChanged();
    }
    
    /**
     * Methods for Un-completing an activity
     */
    @Override
    public void UncompleteFloatingTask(ReadOnlyActivity activityToUncomplete) throws ActivityNotFoundException {
        
        activityManager.unCompleteFloatingTask(activityToUncomplete);
        indicateActivityManagerChanged();
    }

    @Override
    public void UncompleteTask(ReadOnlyActivity activityToUncomplete) throws ActivityNotFoundException {
        
        activityManager.unCompleteTask(activityToUncomplete);
        indicateActivityManagerChanged();
    }

    @Override
    public void editFloatingTaskName(ReadOnlyActivity floatingTaskToEdit, String changes) throws IllegalValueException, ActivityNotFoundException {
        
        activityManager.editFloatingTaskName(floatingTaskToEdit, changes);
        indicateActivityManagerChanged();
    }
    
    @Override 
    public void editTaskName(ReadOnlyActivity taskToEdit, String changes) throws IllegalValueException, ActivityNotFoundException {
        
        activityManager.editTaskName(taskToEdit, changes);
        indicateActivityManagerChanged();
    }
    
    @Override
    public void editEventName(ReadOnlyActivity eventToEdit, String changes) throws IllegalValueException, ActivityNotFoundException {
        
        activityManager.editEventName(eventToEdit, changes);
        indicateActivityManagerChanged();
    }

    /**
     * Methods for editting Activity's note
     * @throws IllegalValueException 
     */
    @Override
    public void editFloatingTaskNote(ReadOnlyActivity floatingTaskToEdit, String changes) throws IllegalValueException, ActivityNotFoundException {
        
        activityManager.editFloatingTaskNote(floatingTaskToEdit, changes);
        indicateActivityManagerChanged();
    }

    @Override
    public void editTaskNote(ReadOnlyActivity taskToEdit, String changes) throws IllegalValueException, ActivityNotFoundException {
        activityManager.editTaskNote(taskToEdit, changes);
        indicateActivityManagerChanged();
    }
    
    @Override
    public void editEventNote(ReadOnlyActivity eventToEdit, String changes) throws IllegalValueException, ActivityNotFoundException {
        
        activityManager.editEventNote(eventToEdit, changes);
        indicateActivityManagerChanged();
    }
    
    /**
     * Methods for editting Activities Starting Date & Time
     * @throws IllegalValueException 
     */
    @Override
    public void editTaskToFloating(ReadOnlyActivity taskToEdit)
            throws IllegalValueException, ActivityNotFoundException {
        
        activityManager.editTaskToFloating(taskToEdit);
        indicateActivityManagerChanged();
        
    }
    
    @Override
    public void editTaskDateTime(ReadOnlyActivity taskToEdit, String newDate, String newTime) throws IllegalValueException, ActivityNotFoundException {
        
        activityManager.editTaskDateTime(taskToEdit, newDate, newTime);
        indicateActivityManagerChanged();
    }
    
    @Override 
    public void editEventStartDateTime(ReadOnlyActivity eventToEdit, String newDate, String newTime) throws IllegalValueException, ActivityNotFoundException {
        
        activityManager.editEventStartDateTime(eventToEdit, newDate, newTime);
        indicateActivityManagerChanged();
        
    }
    
    @Override
    public void editEventEndDateTime(ReadOnlyActivity eventToEdit, String newDate, String newTime) throws IllegalValueException, ActivityNotFoundException {
        
        activityManager.editEventEndDateTime(eventToEdit, newDate, newTime);
        indicateActivityManagerChanged();
    }
    
```
